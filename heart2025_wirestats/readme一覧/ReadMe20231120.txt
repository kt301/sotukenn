                                                 2023/11/08 瀬戸 初版
                                                 2023/11/11 瀬戸 定式化修正、説明追加
						 2023/11/13 瀬戸 バグ修正
						 2023/11/13r2 瀬戸 バグ修正
						 2023/11/20 西原 GraphViz描画機能を追加
2023/11/20 変更点
・PEAロジッククラスに、GraphViz関係のメソッドを2つ追加
  ・.saveGraph_AC(以前提出したsaveGraphと互換)
    -> 配線されていない接続も含め、全部接続
  ・.saveGraph(配置配線結果に応じたGraphVizグラフを生成)
    -> 配線、バインドされいているノードを赤くし、
       配線された接続のみを表示

2023/11/13r2 変更点
・バグを修正(フィードバック・フィードフォワード用の出力MUX (skipOMUX)に
  入力数制約がつけられていなかったバグを修正)

2023/11/13 変更点
・Interconnectクラスを作成する際に、skip配線(skipOMUX)が考慮されていなかった
  バグを修正(フィードバック・フィードフォワード配線が用いられていなかった)

2023/11/11 変更点

・サンプルのeFPGAアーキテクチャを、2x2に簡略化(デバッグのため)
・定式化のバグ修正(不足していた制約(2件)の追加)
・例題(sample.net)を、解が得られるように修正
  (外部入力は、初段のレーンにしかつながっていないのに、
  後段のレーンに配置されなければならないPEAセルが、外部入力を入力する
  ような例題になっており、解が見つけられない例となっていた）
・PEAセルの任意の出力を外部出力にできるようにした。
  

■概要

SATベース配置配線ツール
 PEAセルの新規配線構造に対して、SATベースの配置配線を行うツールです。

■SATソルバーのインストール
SATソルバーは、minisatをインストールしてください。
sudo apt install minisat

■ツールの実行方法
python3 pea.py sample.net

■フォルダ構成
pea.py : ツール
sample.net : ネットリストファイル (con1.net, small.net, one.netもデバッグ用例題ネットリスト)
sample.cnf : ツールから出力された、SATの入力ファイル
sample.rcnf : sample.cnfにて、変数ID番号を変数名にし、人間が読みやすくしたデバッグ用ファイル
sample.output : sample.cnfをSATソルバーに入力して得られた結果の変数割り当てファイル
(pea.py内で、SATソルバー(minisat sample.cnf sample.output)を実行)
sample.dot : ネットリストの簡単なgraphvizグラフ

testcases/: デバッグに使用したテストケース

■SATの定式化の概要

配置配線問題を、SAT式の形式で定式化し、その解を求めることで、配置配線結果を得る。

■　SATの決定変数

大きく分けて2種類

バインド(配置)変数 b_{i,j}の値で、配置が決定する。
iはPEAインスタンス(ネットリスト内のPEA)、jはIP中のPEAセルを表す。
b_{i,j}=1のとき、PEAインスタンスiを、PEAセルjに配置することを
バインド(配置)することを表す。

接続変数c_{s,m,d}の値で、配線が決定する。
sがPEA出力/外部入力、mが出力MUX (None(無し)の場合もあり)、
dがPEA入力(入力MUX)、外部出力を表す。
c_{s,m,d}=1のとき、sから、mをへて、dに接続(配線)することを表す。

そのため、制約条件を満たすように、b_{i,j}とc_{s,m,d}への0,1の
割り当てをSATソルバーで求めることで、配置配線を実行できる。

以下、少し詳細に（繰り返しも含む）説明する。

--------------

PAEインスタンスiを、PAEセルjにバインド(配置)するとき1となる変数 (BindVar):
b_{i,j}

PAEセルの出力sから、出力MUX mを経由して、PAEセルの入力(またはPO)dに
接続するとき1，接続しないとき0となる変数 (ConnectVar):
(出力MUXを経由しない配線は、mがNoneとなる)
c_{s, m, d}

PAEセルの出力sが、出力MUXに接続されるとき1となる変数 (OMUXUsageVar):
(PAEセルの出力sが、出力MUX mを使用するという変数。mの入力数のリソース制約に
用いる補助変数)
u_{s, m}

始点(PAEセルの出力/PI) sから、終点(PAEセルの入力/PO) dに接続することを表す変数
(WireVar): 
(配置に伴う接続制約に使う補助変数）
w_{s, d}


■　制約・補助変数の定義（６種類）

以下で、|は論理和, &は論理積、!は論理否定を表す

MaxMapping制約
各PAEセルjには、最大１個のPEAインスタンスがマッピングされる。
このことを、CNF式で表現するには、任意の２つのバインド変数の組合せが、
同時に１でないと言い換えられるので、以下のように書ける。
(!b_{0,j} + !b_{1,j}) & (!b_{0,j} + !b_{2,j}) & ... (式1)

--------------

Mapping制約
各PAEインスタンスiは、いずれかのPAEセルjにマッピングされる
b_{i,0} | b_{i,1} | b_{i,2} | ...    (式2)

--------------

OMUXUsage制約
異なるPAEセルの出力が、同じ出力MUXを使用してはいけない。
-> 最大1個のPAEセルが、各出力MUXを使用する

(!u_{s1,m} + !u_{s2,m}) & (!u_{s1,m} + !u_{s3,m}) & ... (式3)
(任意の２つのバインド変数の組合せが、同時に１でない。式(1)と同様。)

--------------

OMUXUsageVar制約　（補助変数の定義） 

PAE出力sから出力MUX mを経て、入力MUX(またはPO)dに接続する配線
s->m->d1, s->m->d2, ...を選ぶ変数を、c_{s, m, d1}, c_{s, m, d2}, ...
とすると、これらのどれか一つ以上(マルチファンアウトの場合もあり）が、選ばれたら、
u_{s, m}が1になる。つまり、以下の式が成り立つ

c_{s, m, d1} | c_{s, m, d2} | c_{s, m, d3} | ... -> u_{s, m} 　　(式4)
<=>
(!c_{s, m, d1} + u_{s, m}) & (!c_{s, m, d2} + u_{s, m}) & (!c_{s, m, d3} + u_{s, m}) & ...)
(a -> b <=> !a | bの関係を使用して、CNF形式に変換)

--------------

IMUXUsage制約 (OMUXUsage制約と同様)
異なるPI、出力MUXが、同じ入力MUXを使用してはいけない
-> 最大1個の配線が、終点として、各入力MUXを使用する


PI(またはPEA出力から直接、あるいは出力MUXをへて)からPEA入力(入力MUX) dに
接続する配線を表す変数c_{s1, m1, d}, c_{s2, None, d}, c_{s3, m3, d}, ...
とすると(つまり、特定のdに関するすべてのc_{si, mj, d}を集めて、これらが
1となるのは最大でも１個でなければならない)
(特定のPEA入力(入力MUX)に接続する配線が２本以上存在してはならない）

for each IMUX (PAE入力) d,
c_{s1, m1, d} + c_{s2, m2, d} + c_{s3, m3, d}.... <= 1 
<=> 
(!c_{s1, m1, d} + !c_{s2, m2, d}) & (!c_{s1, m1, d} + !c_{s3, m3, d}) & ...  (式5)
(任意の２つの変数の組合せが、同時に１でない)

--------------

WireVar制約    （補助変数の定義） 

PAEセルの出力s(またはPI)から、PAEセルの入力(またはPO) dに接続する変数 w_{s,d}
接続の際、出力MUX m1, m2, ...（c_{s,m1,d}, c_{s,m2,d}, ...）
のいずれかを経由して接続するとする。

つまり、以下の式が成立する必要

w_{s,d} -> c_{s,m1,d} | c_{s,m2,d} | c_{s,m3,d} |
<=>
!w_{s,d} | c_{s,m1,d} | c_{s,m2,d} | c_{s,m3,d} |  ...  (式6)

--------------

BindConnect制約

バインドが決まったら、ネットリストの接続情報(Edgeクラス)から、
PEA Logicにおける、配線情報が決まるので、それを定式化する。

具体的には、ネットリストの各エッジ e = (s, d)について、以下を行う。

バインド(配置)の結果(可能性をすべて列挙)、s(d)に対応する、
PE Logic上でのPAEセル上の出力(入力)およびPI(PO)をすべて列挙

具体的には、以下のようなアルゴリズムで制約を生成
for each edge e=(s, d) in ネットリスト, 
  for each s_binding (s_bindingは、inst(s)のバインド候補)
    for each d_binding (d_bindingは、inst(d)のバインド候補)
b_{inst(s), s_binding} && b_{inst(d), d_binding} -> c_{binding_port(s, s_binding), binding_port(d, d_binding)}  
(s_binding, d_bindingは、PAECellか、PEA LogicのPI/PO)
<=>
!b_{inst(s), s_binding} | !b_{inst(d), d_binding} | c_{binding_port(s, s_binding), binding_port(d, d_binding)}   (式7)


BindConnect制約と一緒に、以下の制約も追加した。

netlistのedge（接続)を、物理的な配線のいずれかとして実現する必要がある条件：
ネットリストのEdge e=(s,d)に対して、それを実現する配線が無いバインディングは、
除外する必要がある。具体的には、以下のようにした。

srcからdstに接続する配線が存在しないとき、
srcInstをsrcBinding (sbv=1)に、かつ、
同時にdstInstをdstBindingにバインド(配置) (dbv=1)することはできない。
これを条件に表現する。つまり、バインド変数を0に設定する必要がある。
!(sbv & dbv)
<=> !sbv + !dbv
この条件を、bindConnectConstraintに追加した。

--------------

